# Среда исполнения, управление памятью, виртуальная память

Created: September 10, 2023 3:35 PM

# env переменная 

Ссылка: https://github.com/dead-seeds/Course2/blob/main/Semester1/OperatingSystems/Files/environmental-variable%20(1).md#environmental-variables

# fgets()

`fgets()` - Читает максимум количество символов `count - 1` из файла потока и сохраняет их в `str`. Парсинг останавливается, если достигнут 
конец файла или символ новой строки не найден, и в этом случае `str` будет содержать этот символ новой строки.

Параметры
`str`	-	Указатель на массив типа `char`, в который сохраняются считанные символы.
`count`	-	Максимальное количество символов для чтения, включая нулевой символ.
`stream`	-	Указатель на объект типа `FILE`, который идентифицирует поток, из которого считываются символы.

Источник: https://en.cppreference.com/w/c/io/fgets

# strlen()

`strlen( const char* str )` - Возвращает длину заданной строки байтов, то есть количество символов в массиве символов, на первый элемент которого указывает `str`, 
до первого нулевого символа и не включая его. Поведение не определено, если в массиве символов, на который указывает `str`, нет нулевого символа.

Параметры
`str`	—	указатель на строку байтов с нулевым завершающим символом, подлежащую проверке

Источник: https://en.cppreference.com/w/cpp/string/byte/strlen

# sizeof()

`sizeof()` - Используется, когда необходимо знать фактический размер объекта. 
1) Выдаёт размер в байтах объектного представления для типа.
2) Выдаёт размер в байтах объектного представления типа выражения, если это выражение оценивается.

При применении к ссылочному типу результатом является размер ссылочного типа.

При применении к типу класса результатом является количество байтов, занятых полным объектом этого класса, включая любые дополнительные отступы, необходимые для размещения такого объекта в массиве. Количество байтов, занимаемых потенциально перекрывающимся подобъектом, может быть меньше размера этого объекта.
Результат sizeof всегда отличен от нуля, даже если он применяется к пустому типу класса.
При применении к выражению sizeof не оценивает выражение, и даже если выражение обозначает полиморфный объект, результатом является размер статического типа выражения. 

Источник: https://en.cppreference.com/w/cpp/language/sizeof

# Возможные вопросы

- Можем ли мы использовать sizeof с массивом, если инициализировали его динамически с помощью malloc?
- (в случае выделения памяти методом char x[1024];) Что будет, если мы введем больше символов, чем обозначали?
- Выделять память большими кусками и выделять память маленькими кусками. Какие проблемы могут возникнуть в обоих случаях?
- Что такое env переменная?
- Что будет, если задать переменную TZ внутри процесса? Изменится ли время на всей машине?


   

