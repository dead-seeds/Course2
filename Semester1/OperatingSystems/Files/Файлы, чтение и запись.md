# Файлы, каталоги и традиционные права доступа

Created: September 9, 2023 4:13 PM

`size_t` - ?

`ssize_t` - ?

`off_t` - ?


# File descriptor

Функция `open(const char *pathname, int flags)` возвращает дескриптор файла (неотрицательное целое число int). Файловый дескриптор, который нам вернули - это индекс в в системной таблице открытых файловых дескрипторов, по которому было создано новое описание файла. В нём же записывается в том числе flags, полный лист которых стоит просто почитать в `man 2 open` или `man 2 fcntl`. 

В ранних версиях UNIX не существовал заголовочный
файл `<fcntl.h>` , и в параметре `flags`  непосредственно задавались численные
значения. (src - Хэвиленд)

Отдельно надо знать про сигнатуру `open(const char *pathname, int flags, mode_t mode)` , тк если мы создаем новый файл таким образом, мы с помощью `mode` задаём `access permissions` к этому файлу.


# read()

`read(int fd, void *buffer, size_t n)` читает из файлового дескриптора не больше нужного нам числа байтов и возвращает `ssize_t` количество считанных (в прежних версиях UNIX был `int` (31ая страница Хэвиленда), но инт с появлениями новых версий может менять свой размер, так что был введён `ssize_t`). Если файл поддерживает поиск, то смещение (offset) увеличивается на число считанных байтов. Если offset был уже в конце файла, то считываются 0 байтов и read возвращает 0. read не возвращает ошибку, если считал <запрошенного числа байтов, так что нужно проверять, сколько мы в итоге считали, если из-за этого могут возникнуть приколы.
`read()` никак не преобразует считанные байты, он просто один из нижних кирпичиков, которые, например, вызывает `scanf()` и подобные ребята.

Система отслеживает текущее положение в файле при помощи объекта, кото­
рый называется указателем ввода/вывода (read-write pointer), или указателем
файла (file pointer).


# write()

`write(int filedes, const void *buffer, size_t n)` копирует данные из буфера программы, рассматриваемого как массив, во внешний файл.


# close()

Логично, что `close(int fd)`закрывает файловый дескриптор, тот больше не используется и может быть переиспользован. Все блокировки, которыми владел процесс, снимаются. Если это последний `fd`, связанный с file description, место из-под file description освобождается.

`close()` возвращает 0 при успехе и -1 при ошибке.


# lseek()

Осуществляет произвольный доступ, изменяющий положение r-w pointer’а.
